import streamlit as st
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import networkx as nx
import pandas as pd
import base64
import io
from PIL import Image
import json
import requests
import sys
import os
import random

# Add current directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from app.network_builder import NetworkBuilder
from app.visualizer import Visualizer
from app.social_post_generator import SocialPostGenerator

# Page configuration
st.set_page_config(
    page_title="NexusMap Pro - Network Analyzer",
    page_icon="üåê",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid #1f77b4;
    }
    .insight-box {
        background-color: #e8f4fd;
        padding: 1rem;
        border-radius: 10px;
        border: 1px solid #1f77b4;
    }
    .success-box {
        background-color: #d4edda;
        padding: 1rem;
        border-radius: 10px;
        border: 1px solid #28a745;
    }
</style>
""", unsafe_allow_html=True)

def create_interactive_network_plotly(graph):
    """Create an interactive network visualization using Plotly"""
    # Get positions using spring layout
    pos = nx.spring_layout(graph, k=3, iterations=50)
    
    # Extract node and edge information
    node_x = []
    node_y = []
    node_text = []
    node_color = []
    node_size = []
    
    for node in graph.nodes():
        x, y = pos[node]
        node_x.append(x)
        node_y.append(y)
        
        # Node info
        node_info = graph.nodes[node]
        connection_type = node_info.get('connection_type', '')
        if connection_type:
            node_text.append(f"{node}<br>{node_info.get('title', 'Professional')}<br>Connection: {connection_type}")
        else:
            node_text.append(f"{node}<br>{node_info.get('title', 'Professional')}")
        
        # Color coding based on group
        group = node_info.get('group', 'Other')
        if group == 'Central':
            node_color.append('#FF6B6B')  # Red for central node
            node_size.append(25)
        elif group == 'Follower':
            node_color.append('#4ECDC4')  # Teal for followers
            node_size.append(15)
        elif group == 'Following':
            node_color.append('#45B7D1')  # Blue for following
            node_size.append(15)
        elif node_info.get('connection_type') == '2nd':
            node_color.append('#FFA500')  # Orange for 2nd degree connections
            node_size.append(10)
        else:
            # Get color based on industry for 1st degree connections
            industry = group
            industry_colors = {
                'Tech': '#4287f5',
                'Finance': '#41c871',
                'Healthcare': '#f54242',
                'Education': '#9941f5',
                'Consulting': '#f5a142',
                'Marketing': '#42f5e9',
                'Design': '#f542d4',
                'Engineering': '#42f578',
                'Sales': '#f5d742',
                'Human Resources': '#8c7ae6',
                'Product': '#c56cf0',
                'Research': '#3ae374',
                'Operations': '#32ff7e'
            }
            node_color.append(industry_colors.get(industry, '#7158e2'))  # Default purple if industry not found
            node_size.append(15)
        
    # Create edges
    edge_x = []
    edge_y = []
    
    for edge in graph.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_x.extend([x0, x1, None])
        edge_y.extend([y0, y1, None])
    
    # Create the plot
    fig = go.Figure()
    
    # Add edges
    fig.add_trace(go.Scatter(
        x=edge_x, y=edge_y,
        line=dict(width=0.8, color='#888'),
        hoverinfo='none',
        mode='lines'
    ))
    
    # Add nodes
    fig.add_trace(go.Scatter(
        x=node_x, y=node_y,
        mode='markers',
        hoverinfo='text',
        text=node_text,
        marker=dict(
            showscale=False,
            color=node_color,
            size=node_size,
            line=dict(width=1, color='#444')
        )
    ))
    
    # Add legend with markers for connection types
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=15, color='#FF6B6B'),
        name='You (Central)'
    ))
    
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=10, color='#4ECDC4'),
        name='Follower'
    ))
    
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=10, color='#45B7D1'),
        name='Following'
    ))
    
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=8, color='#FFA500'),
        name='2nd Degree Connection'
    ))
    
    # Add a few industry color examples to the legend
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=10, color='#4287f5'),
        name='Tech Industry'
    ))
    
    fig.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='markers',
        marker=dict(size=10, color='#41c871'),
        name='Finance Industry'
    ))
    
    # Set layout
    fig.update_layout(
        showlegend=True,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=-0.2,
            xanchor="center",
            x=0.5
        ),
        title="",
        hovermode="closest",
        margin=dict(b=40, l=40, r=40, t=40),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor="#F9F9F9",
        paper_bgcolor="#F9F9F9",
        autosize=True,
    )
    
    return fig

def create_stats_charts(stats, graph):
    col1, col2 = st.columns(2)
    
    with col1:
        # Connection Types
        connection_types = {}
        for node in graph.nodes():
            if node == "You": continue
            
            group = graph.nodes[node].get('group', 'Other')
            if group in connection_types:
                connection_types[group] += 1
            else:
                connection_types[group] = 1
        
        # Create a DataFrame for the pie chart
        connection_df = pd.DataFrame({
            'Group': list(connection_types.keys()),
            'Count': list(connection_types.values())
        })
        
        fig = px.pie(connection_df, 
                    values='Count', 
                    names='Group', 
                    title='Network Composition by Group',
                    color_discrete_sequence=px.colors.qualitative.Set2)
        
        fig.update_traces(textposition='inside', textinfo='percent+label')
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        # Network Metrics
        metrics = {
            'Density': stats['density'],
            'Avg Clustering': stats['clustering'],
            'Centrality': stats['centrality'],
            'Connectedness': stats['connectedness'],
        }
        
        # Create a DataFrame for the bar chart
        metrics_df = pd.DataFrame({
            'Metric': list(metrics.keys()),
            'Value': list(metrics.values())
        })
        
        fig = px.bar(metrics_df, 
                    x='Metric', 
                    y='Value',
                    title='Network Metrics',
                    color='Metric',
                    color_discrete_sequence=px.colors.qualitative.Safe)
        
        fig.update_layout(xaxis_title="", yaxis_title="Score (0-1)")
        st.plotly_chart(fig, use_container_width=True)

def create_personalized_linkedin_demo(username):
    """Create a personalized LinkedIn demo based on username"""
    import random
    
    graph = nx.Graph()
    
    # Create personalized central node - handle URLs or usernames
    if "linkedin.com/in/" in username:
        # Extract just the username from URL
        username = username.split("linkedin.com/in/")[-1].strip("/").split("?")[0]
    
    # Clean up username for display
    display_name = username.replace(".", " ").replace("-", " ").replace("_", " ").title()
    
    # Add user as central node
    graph.add_node("You", 
                  size=30, 
                  title=f"{display_name}\nProfessional Network",
                  group="Central")
    
    # Create more realistic connections based on username
    industries = ["Tech", "Finance", "Healthcare", "Education", "Consulting", "Marketing", "Design", 
                 "Engineering", "Sales", "Human Resources", "Product", "Research", "Operations"]
    companies = ["TechCorp", "DataInc", "InnovateLabs", "FutureWorks", "SmartSolutions", "NextGen", 
                "ProAnalytics", "GlobalTech", "InnovateAI", "CloudSystems", "FinTech Solutions", 
                "HealthTech", "EduTech", "ConsultGroup"]
    
    # Generate connections that feel personalized but realistic
    random.seed(hash(username) % 1000)  # Consistent results for same username
    
    # Generate primary connections (direct connections)
    primary_connections = []
    num_primary = random.randint(15, 25)  # More realistic LinkedIn connection count
    
    first_names = ["Sarah", "Mike", "Emily", "Alex", "Jennifer", "David", "Rachel", "Tom", "Lisa", "Chris",
                  "Mohammed", "Aisha", "Wei", "Priya", "Carlos", "Sofia", "Jamal", "Elena", "Ahmed", "Zoe"]
    last_names = ["Johnson", "Chen", "Davis", "Rodriguez", "Liu", "Park", "Green", "Wilson", "Brown", "Taylor",
                 "Patel", "Nguyen", "Garcia", "Kim", "Singh", "Muller", "Williams", "Martinez", "Lee", "Khan"]
    
    for i in range(num_primary):
        name = f"{random.choice(first_names)} {random.choice(last_names)}"
        company = random.choice(companies)
        industry = random.choice(industries)
        
        titles = [
            f"Senior {industry} Manager at {company}",
            f"Lead {industry} Analyst at {company}",
            f"{industry} Director at {company}",
            f"Principal {industry} Consultant at {company}",
            f"{industry} Product Manager at {company}",
            f"{industry} Specialist at {company}",
            f"Head of {industry} at {company}",
            f"{industry} Engineer at {company}",
            f"VP of {industry} at {company}"
        ]
        
        connection_type = "1st"
        if random.random() < 0.2:  # 20% chance of being a follower
            connection_type = "Follower"
        
        primary_connections.append({
            "name": name,
            "title": random.choice(titles),
            "company": company,
            "industry": industry,
            "type": connection_type
        })
    
    # Add primary connections to graph
    for conn in primary_connections:
        node_size = 12
        if conn["type"] == "Follower":
            group = "Follower"
        else:
            group = conn["industry"]
        
        graph.add_node(conn["name"], 
                      size=node_size, 
                      title=conn["title"],
                      group=group,
                      connection_type=conn["type"])
        
        graph.add_edge("You", conn["name"])
    
    # Add some 2nd-degree connections (connections of connections)
    secondary_connections = []
    num_secondary = random.randint(5, 10)
    
    for i in range(num_secondary):
        name = f"{random.choice(first_names)} {random.choice(last_names)}"
        company = random.choice(companies)
        industry = random.choice(industries)
        
        titles = [
            f"Senior {industry} Manager at {company}",
            f"Lead {industry} Analyst at {company}",
            f"{industry} Director at {company}",
            f"Principal {industry} Consultant at {company}",
            f"{industry} Product Manager at {company}"
        ]
        
        # Connect to a random primary connection
        connected_to = random.choice(primary_connections)["name"]
        
        secondary_connections.append({
            "name": name,
            "title": random.choice(titles),
            "company": company,
            "industry": industry,
            "connected_to": connected_to
        })
    
    # Add secondary connections
    for conn in secondary_connections:
        graph.add_node(conn["name"], 
                      size=8,  # Smaller size for 2nd degree
                      title=conn["title"],
                      group=conn["industry"],
                      connection_type="2nd")
        
        graph.add_edge(conn["connected_to"], conn["name"])
    
    # Add inter-connections among primary connections for realism
    primary_names = [conn["name"] for conn in primary_connections]
    num_inter_connections = random.randint(num_primary // 3, num_primary // 2)
    
    for i in range(num_inter_connections):
        if len(primary_names) >= 2:
            conn1, conn2 = random.sample(primary_names, 2)
            if not graph.has_edge(conn1, conn2):
                graph.add_edge(conn1, conn2)
    
    return graph

def analyze_github_user(username):
    """Analyze a GitHub user's network"""
    try:
        builder = NetworkBuilder()
        graph = builder.from_github(username)
        return graph, True, None
    except Exception as e:
        return None, False, str(e)

def analyze_linkedin_profile(profile_url):
    """Analyze a LinkedIn profile URL"""
    try:
        # Extract username from profile URL
        if "linkedin.com/in/" in profile_url:
            username = profile_url.split("linkedin.com/in/")[-1].strip("/").split("?")[0]
            
            # Try to get additional profile info if possible (optional enhancement)
            try:
                import requests
                from bs4 import BeautifulSoup
                
                # Note: This is a demonstration only - a real implementation would use LinkedIn's API
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                
                # Note: This is not actually making a real request - it's just simulating what could be done
                # with official LinkedIn API access
                profile_data = {
                    'username': username,
                    'display_name': username.replace(".", " ").replace("-", " ").replace("_", " ").title(),
                    'headline': 'Professional on LinkedIn',
                    'company': 'LinkedIn',
                }
                
            except Exception as e:
                # Fall back to just username information
                profile_data = {
                    'username': username,
                    'display_name': username.replace(".", " ").replace("-", " ").replace("_", " ").title(),
                }
            
            # Create a personalized demo with the username
            graph = create_personalized_linkedin_demo(username)
            return graph, True, profile_data
        else:
            return None, False, "Invalid LinkedIn profile URL"
    except Exception as e:
        return None, False, str(e)

def main():
    st.markdown("<h1 class='main-header'>üåê NexusMap Pro</h1>", unsafe_allow_html=True)
    st.markdown("### Professional Network Analyzer & Visualization Tool")
    
    # Sidebar Setup
    st.sidebar.title("Network Settings")
    
    network_source = st.sidebar.radio(
        "Choose Network Source:",
        ["GitHub", "LinkedIn"],
        index=0
    )
    
    # Initialize session state
    if 'graph' not in st.session_state:
        st.session_state.graph = None
    if 'stats' not in st.session_state:
        st.session_state.stats = None
    if 'analysis_complete' not in st.session_state:
        st.session_state.analysis_complete = False
    
    # Input based on source
    if network_source == "GitHub":
        st.sidebar.markdown("### GitHub Analysis")
        username = st.sidebar.text_input("Enter GitHub Username:", placeholder="e.g., octocat")
        
        if st.sidebar.button("üöÄ Analyze Network", type="primary"):
            if username:
                with st.spinner("üîç Analyzing your GitHub network..."):
                    graph, success, error = analyze_github_user(username)
                    
                    if success and graph:
                        st.session_state.graph = graph
                        st.session_state.stats = SocialPostGenerator.generate_stats(graph)
                        st.session_state.analysis_complete = True
                        st.success(f"‚úÖ Successfully analyzed {username}'s network!")
                    else:
                        st.error(f"‚ùå Error analyzing network: {error}")
            else:
                st.warning("‚ö†Ô∏è Please enter a GitHub username")
    
    elif network_source == "LinkedIn":
        st.sidebar.markdown("### LinkedIn Analysis")
        st.sidebar.info("üîó Enter your LinkedIn profile URL or email to analyze your professional network.")
        
        # LinkedIn input options
        linkedin_input_type = st.sidebar.radio(
            "Choose input method:",
            ["Profile URL", "Email (Demo Mode)"]
        )
        
        if linkedin_input_type == "Profile URL":
            linkedin_url = st.sidebar.text_input(
                "LinkedIn Profile URL:", 
                placeholder="https://linkedin.com/in/yourname"
            )
            
            if st.sidebar.button("üîó Analyze LinkedIn Network", type="primary"):
                if linkedin_url:
                    # Process LinkedIn URL
                    if "linkedin.com/in/" in linkedin_url:
                        with st.spinner("üîç Analyzing your LinkedIn network..."):
                            graph, success, profile_data = analyze_linkedin_profile(linkedin_url)
                            
                            if success and graph:
                                st.session_state.graph = graph
                                st.session_state.stats = SocialPostGenerator.generate_stats(graph)
                                st.session_state.analysis_complete = True
                                
                                # Display success with profile name
                                if isinstance(profile_data, dict) and 'display_name' in profile_data:
                                    display_name = profile_data['display_name']
                                else:
                                    # Extract username for display
                                    username = linkedin_url.split("linkedin.com/in/")[-1].strip("/").split("?")[0]
                                    display_name = username.replace(".", " ").replace("-", " ").replace("_", " ").title()
                                
                                st.success(f"‚úÖ Successfully analyzed {display_name}'s LinkedIn network!")
                                st.info("üìù Note: This is a realistic demo visualization based on your profile URL. For full LinkedIn data access, official API integration is required.")
                            else:
                                error_msg = profile_data if isinstance(profile_data, str) else "Unknown error"
                                st.error(f"‚ùå Error analyzing LinkedIn profile: {error_msg}")
                    else:
                        st.error("‚ùå Please enter a valid LinkedIn profile URL that includes 'linkedin.com/in/'")
                else:
                    st.warning("‚ö†Ô∏è Please enter a LinkedIn profile URL")
        
        else:  # Email (Demo Mode)
            email = st.sidebar.text_input(
                "Your Email:", 
                placeholder="you@example.com"
            )
            
            if st.sidebar.button("üìß Generate Demo Network", type="primary"):
                if email and "@" in email:
                    with st.spinner("üîç Creating personalized demo network..."):
                        # Create a username from email
                        username = email.split("@")[0]
                        graph = create_personalized_linkedin_demo(username)
                        
                        st.session_state.graph = graph
                        st.session_state.stats = SocialPostGenerator.generate_stats(graph)
                        st.session_state.analysis_complete = True
                        st.success(f"‚úÖ Created personalized demo network!")
                        st.info("üìù Note: This is a demo visualization. For full LinkedIn data, official API access is required.")
                else:
                    st.warning("‚ö†Ô∏è Please enter a valid email address")
    
    # Display Analysis Results
    if st.session_state.analysis_complete and st.session_state.graph:
        # Header & Key Metrics
        st.header("üìä Network Analysis Results")
        
        # Display key metrics in columns
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.markdown("""
            <div class="metric-card">
                <h3>Network Size</h3>
                <h2>{} connections</h2>
            </div>
            """.format(len(st.session_state.graph.nodes()) - 1), unsafe_allow_html=True)
        
        with col2:
            density = st.session_state.stats['density']
            st.markdown("""
            <div class="metric-card">
                <h3>Network Density</h3>
                <h2>{:.2f}</h2>
            </div>
            """.format(density), unsafe_allow_html=True)
        
        with col3:
            centrality = st.session_state.stats['centrality']
            st.markdown("""
            <div class="metric-card">
                <h3>Your Centrality</h3>
                <h2>{:.2f}</h2>
            </div>
            """.format(centrality), unsafe_allow_html=True)
        
        with col4:
            clusters = st.session_state.stats['clusters']
            st.markdown("""
            <div class="metric-card">
                <h3>Network Clusters</h3>
                <h2>{}</h2>
            </div>
            """.format(clusters), unsafe_allow_html=True)
        
        # Network Visualization & Insights
        st.header("üåê Network Visualization")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            fig = create_interactive_network_plotly(st.session_state.graph)
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.subheader("üí° Key Insights")
            
            density = st.session_state.stats['density']
            centrality = st.session_state.stats['centrality']
            
            if density > 0.3:
                density_insight = "highly connected"
                density_desc = "Your network shows strong clustering and tight-knit connections."
            else:
                density_insight = "diverse and spread out"
                density_desc = "Your network spans across diverse groups and industries."
            
            if centrality > 0.8:
                centrality_insight = "central hub"
                centrality_desc = "You're at the center of your network with high influence."
            else:
                centrality_insight = "well-connected node"
                centrality_desc = "You have good connections but share influence with others."
            
            st.markdown(f"""
            <div class="insight-box">
                <h4>üéØ Network Position</h4>
                <p>You're a <strong>{centrality_insight}</strong> in your network.</p>
                <p>{centrality_desc}</p>
            </div>
            """, unsafe_allow_html=True)
            
            st.markdown(f"""
            <div class="insight-box">
                <h4>üåê Network Structure</h4>
                <p>Your network is <strong>{density_insight}</strong>.</p>
                <p>{density_desc}</p>
            </div>
            """, unsafe_allow_html=True)
        
        # Additional Charts
        st.header("üìà Detailed Analysis")
        create_stats_charts(st.session_state.stats, st.session_state.graph)
        
        # LinkedIn Post Generation
        st.header("üî• LinkedIn Post Generator")
        
        post = SocialPostGenerator.generate_post(st.session_state.stats)
        
        st.markdown("""
        <div class="success-box">
            <h4>üìù Your LinkedIn-Ready Post:</h4>
        </div>
        """, unsafe_allow_html=True)
        
        st.text_area("LinkedIn Post Copy:", value=post, height=300)
        
        # Download buttons
        st.header("üìÅ Download Results")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            # Create visualization file
            try:
                if not os.path.exists('output'):
                    os.makedirs('output')
                
                viz_path = Visualizer.create_interactive(st.session_state.graph)
                
                with open(viz_path, "r") as f:
                    html_string = f.read()
                
                st.download_button(
                    label="üìä Download Interactive HTML",
                    data=html_string,
                    file_name="network_visualization.html",
                    mime="text/html"
                )
            except Exception as e:
                st.error(f"Error creating visualization: {e}")
        
        with col2:
            # Create PNG visualization
            try:
                png_path = Visualizer.create_static(st.session_state.graph)
                
                with open(png_path, "rb") as f:
                    img_bytes = f.read()
                
                st.download_button(
                    label="üñºÔ∏è Download PNG Image",
                    data=img_bytes,
                    file_name="network_visualization.png",
                    mime="image/png"
                )
            except Exception as e:
                st.error(f"Error creating PNG: {e}")
        
        with col3:
            # Network statistics as JSON
            stats_json = json.dumps(st.session_state.stats, indent=2)
            
            st.download_button(
                label="üìã Download Network Stats",
                data=stats_json,
                file_name="network_stats.json",
                mime="application/json"
            )
    
    else:
        # Welcome Screen
        st.subheader("Welcome to NexusMap Pro!")
        st.write("Analyze your professional network and generate powerful insights.")
        
        # Feature overview
        st.markdown("### ‚ú® Features")
        
        feature_col1, feature_col2, feature_col3 = st.columns(3)
        
        with feature_col1:
            st.markdown("""
            ### üåê Network Analysis
            - GitHub followers/following
            - LinkedIn connections
            - Network visualization
            """)
        
        with feature_col2:
            st.markdown("""
            ### üìä Advanced Metrics
            - Network density
            - Centrality measurements
            - Connection type breakdown
            """)
        
        with feature_col3:
            st.markdown("""
            ### üî• Social Ready
            - Auto-generated LinkedIn posts
            - Professional insights
            - Downloadable results
            """)

if __name__ == "__main__":
    main()
